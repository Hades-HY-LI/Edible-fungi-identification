def test_model(model):
    """
    This function apply trained model on test data. And return its prediction accuracuy
    """
    was_training = model.training
    model.eval()
    running_corrects = 0

    with torch.no_grad():
        for i, (inputs, labels) in enumerate(dataloaders['test']):
            inputs = inputs.to(device)
            labels = labels.to(device)

            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            
            running_corrects += torch.sum(preds == labels.data)
            
        test_acc = running_corrects.double() / dataset_sizes['test']
        model.train(mode=was_training)
    
    return test_acc
    
    

def test_model_recall(model):
    """
    This function apply trained model on test data. And return its prediction accuracuy
    """
    was_training = model.training
    model.eval()
    recall_corrects = 0
    poison_sum = 0

    with torch.no_grad():
        for i, (inputs, labels) in enumerate(dataloaders['test']):
            inputs = inputs.to(device)
            labels = labels.to(device)

            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            
            recall_corrects += torch.sum((preds == labels.data) * (labels.data == 1))
            poison_sum += torch.sum(labels.data == 1)
            
        # test_recall = recall_corrects.double() / poison_sum  # For Nvidia GPU
        test_recall = recall_corrects.float() / poison_sum  # For mac m1 chip
        model.train(mode=was_training)
    
    return test_recall
